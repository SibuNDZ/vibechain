generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String?   @unique
  username      String    @unique
  passwordHash  String?
  walletAddress String?   @unique
  avatarUrl     String?
  bio           String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  videos        Video[]
  votes         Vote[]
  contributions Contribution[]
  comments      Comment[]
  chatConversations ChatConversation[]

  // Follow relationships
  followers     Follow[]  @relation("Following")
  following     Follow[]  @relation("Followers")

  // Direct messaging
  conversationsAsUser1  DirectConversation[] @relation("ConversationUser1")
  conversationsAsUser2  DirectConversation[] @relation("ConversationUser2")
  sentMessages          DirectMessage[]

  @@map("users")
}

model Video {
  id                  String   @id @default(cuid())
  title               String
  description         String?
  videoUrl            String
  thumbnailUrl        String?
  duration            Int      // in seconds
  status              VideoStatus @default(PENDING)
  cloudinaryPublicId  String?  // Cloudinary public_id for video management
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // AI embedding for semantic search (pgvector)
  embedding           Unsupported("vector(1536)")?
  embeddingUpdatedAt  DateTime?

  userId       String
  user         User     @relation(fields: [userId], references: [id])
  votes        Vote[]
  campaign     Campaign?
  comments     Comment[]

  @@index([status])
  @@index([userId])
  @@index([createdAt])
  @@map("videos")
}

enum VideoStatus {
  PENDING
  APPROVED
  REJECTED
  FUNDING
  FUNDED
}

model Vote {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  videoId   String
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@unique([userId, videoId])
  @@index([videoId])
  @@map("votes")
}

model Campaign {
  id                  String   @id @default(cuid())
  goalAmount          Decimal  @db.Decimal(18, 8)
  raisedAmount        Decimal  @default(0) @db.Decimal(18, 8)
  contractAddress     String?
  contractCampaignId  Int?     // The campaign ID on the smart contract
  startDate           DateTime @default(now())
  endDate             DateTime
  status              CampaignStatus @default(ACTIVE)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  videoId       String   @unique
  video         Video    @relation(fields: [videoId], references: [id])
  contributions Contribution[]

  @@index([status])
  @@map("campaigns")
}

enum CampaignStatus {
  ACTIVE
  SUCCESSFUL
  FAILED
  CANCELLED
}

model Contribution {
  id            String   @id @default(cuid())
  amount        Decimal  @db.Decimal(18, 8)
  txHash        String   @unique
  createdAt     DateTime @default(now())

  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  campaignId    String
  campaign      Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([campaignId])
  @@map("contributions")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  videoId   String
  video     Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)

  // Nested replies
  parentId  String?
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[] @relation("CommentReplies")

  @@index([videoId])
  @@index([userId])
  @@index([parentId])
  @@map("comments")
}

model Follow {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())

  followerId  String
  follower    User     @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String
  following   User     @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// Wallet auth nonces to prevent signature replay
model AuthNonce {
  id            String   @id @default(cuid())
  walletAddress String
  nonce         String
  used          Boolean  @default(false)
  expiresAt     DateTime
  createdAt     DateTime @default(now())
  usedAt        DateTime?

  @@unique([walletAddress, nonce])
  @@index([walletAddress])
  @@index([expiresAt])
  @@map("auth_nonces")
}

// AI Chat models
model ChatConversation {
  id        String   @id @default(cuid())
  title     String?  // Auto-generated from first message
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  ChatMessage[]

  @@index([userId])
  @@map("chat_conversations")
}

model ChatMessage {
  id        String   @id @default(cuid())
  role      String   // 'user' | 'assistant'
  content   String
  videoIds  String[] // Video IDs referenced in AI response
  createdAt DateTime @default(now())

  conversationId String
  conversation   ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("chat_messages")
}

// Direct Messaging models
model DirectConversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user1Id   String
  user1     User     @relation("ConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2Id   String
  user2     User     @relation("ConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  messages  DirectMessage[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@map("direct_conversations")
}

model DirectMessage {
  id        String   @id @default(cuid())
  content   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  senderId       String
  sender         User               @relation(fields: [senderId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   DirectConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@map("direct_messages")
}
